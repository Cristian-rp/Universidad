# -*- coding: utf-8 -*-
"""Ejercicio fisica

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lQjLZiQRzSrNOnVmGz6zs5yif8NxFeMp

# Movimiento armortiguado
"""

import sympy as sp # Libreria para trabajar de forma simbolica
import numpy as np # libreria para trabajar numericamente

from scipy.integrate import solve_ivp # Libreria para trabajar con integración

import matplotlib.pyplot as plt # Libreria para crear gráficos y visualizaciones de datos
from matplotlib import animation #Libreria para crear animaciones en gráficos
from mpl_toolkits.mplot3d import Axes3D # Libreria para crear gráficos tridimensionales (3D)

"""Prueba de la libreria symbols"""

x, m, b, t, k = sp.symbols('x m b t k') # Definimos variables
#x
#sp.cos(x*x)
#sp.expand(x*(x+3)+x*(x**2+1))

#x
#sp.cosh(x)
#sp.cos(x**2)
#m*(b+t)+k*(m+t)
sp.expand(m*(b+t)+k*(m+t))# Multiplica termino a termino

x = sp.Function('x', real=True,) #Esta linea crea una funcion
x = x(t)
x

d1_x = sp.diff(x, t) #El diff busca la derivada de la velocidad con (x, t)
d2_x = sp.diff(d1_x, t) #Calcula la derivada del resultado anterior (d1_x) y de t
d1_x #Esto muestra d1_x
d2_x #Esto muestra d2_x

Fr = b*d1_x #Fuerza de rozamiento
Fr

Fx = -k*x -Fr #Fuerza neta o total
Fx

#Mostramos simbolicamente la segunda ley de newton aplicada con los terminos anteriores
Eq = sp.Eq(Fx, m*d2_x)
Eq

x_explicit = sp.dsolve(Eq, x).args[1]
x_explicit
# El x_explicit nos habla de dar una solucion explicita (significa que la solucion se expresa en
# terminos de la variable dependiente en este caso(t))y el args[1]nos menciona
# la posicion que vamos a ver de la ecuacion diferencial(Eq)

x_explicit.diff(t) #Derivada de la ecuacion con respecto a (t)

x_explicit.diff(t, 2) #Segunda derivada de la funcion

x_explicit.integrate(t) #La integral de la funcion

t0 = 0
x0 = 10
vx0 = 0
S0 = {x.subs(t,t0):x0, d1_x.subs(t,t0):vx0}

# A esto se le llama diccionario en Python, ademas, subs sirve para sustituir datos anteriores
# en este caso sustituir t por t0 en la exprecion x(t)

S0

x_explicit = sp.dsolve(Eq, x, ics = S0).args[1] # Se obtiene la solución explícita de la ecuación diferencial dada
x_explicit

d1_x_explicit = sp.diff(x_explicit, t) # Se calcula la primera derivada de la solución explícita x_explicit con respecto a t
d1_x_explicit

# Se sustituye el valor de 'b' en la solución explícita x_explicit
x_explicit.subs([
    [b, sp.sqrt(4*k*m)] # Se reemplaza 'b' por la expresión sqrt(4*k*m)
])

sp.limit(x_explicit, b, sp.sqrt(4*k*m)) # Se calcula el límite de x_explicit cuando 'b' tiende a sqrt(4*k*m)

# Se calcula el límite de x_explicit cuando 'b' tiende a sqrt(4*k*m) por la izquierda y la derecha
sp.limit(x_explicit, b, sp.sqrt(4*k*m), '+-').subs([
    [k, 3] # Reemplaza 'k' por 3 en la expresión obtenida
])

# Se sustituyen los valores de 'k' por 3 y 'm' por 2 en el límite calculado y se simplifica
sp.limit(x_explicit, b, sp.sqrt(4*k*m), '+-').subs([
    [k, 3], # Reemplaza 'k' por 3
    [m, 2] # Reemplaza 'm' por 2
]).simplify(force=True) # Simplifica la expresión final forzando la reducción

# Definición de valores numéricos para los parámetros
mn = 2
kn = 2
bn = 8

if bn**2 == 4*kn*mn:
    x_explicit = sp.limit(x_explicit, b, sp.sqrt(4*k*m), '+-')   # Si bn^2 es igual a 4*k*m, se calcula el límite de x_explicit cuando b -> sqrt(4*k*m)
    x_explicit = x_explicit.subs([
        # Se sustituyen los valores numéricos en la expresión
        [m, mn],
        [k, kn]
    ]).simplify(force=True)# Se simplifica la expresión resultante

    d1_x_explicit = sp.diff(x_explicit, t) # Se calcula la primera derivada con respecto a t
elif bn**2 > 4*kn*mn:

    x_explicit = x_explicit.subs([
        [m, mn],
        [k, kn],
        [b, bn]
    ])

    d1_x_explicit = sp.diff(x_explicit, t)
elif bn**2 < 4*kn*mn:
    # Si bn^2 es mayor que 4*k*m, se sustituyen directamente los valores en la solución
    x_explicit = x_explicit.subs([
        [m, mn],
        [k, kn],
        [b, bn]
    ]).as_real_imag()[0].simplify(force=True) # Se extrae solo la parte real y se simplifica

    d1_x_explicit = sp.diff(x_explicit, t)  # Se calcula la primera derivada con respecto a t

# Se simplifica la expresión de x_explicit forzando la reducción algebraica
x_explicit = x_explicit.simplify(force=True)
x_explicit

# Se simplifica la primera derivada de x_explicit forzando la reducción algebraica
d1_x_explicit = d1_x_explicit.simplify(force=True)
d1_x_explicit

# Se convierte la expresión simbólica de x_explicit en una función numérica evaluable con NumPy
x_exact = sp.lambdify((t), x_explicit, modules='numpy')
# Se convierte la expresión simbólica de la primera derivada en una función numérica evaluable con NumPy
d1_x_exact = sp.lambdify((t), d1_x_explicit, modules='numpy')

# Definición de los parámetros para el intervalo de tiempo
t0 = 0 # Tiempo inicial
tf = 20*np.pi # Tiempo final
t_size = 2001
# Se genera un array de valores de t uniformemente distribuidos entre t0 y tf
t = np.linspace(t0, tf, t_size)

# Se evalúa la función x_exact en el conjunto de valores de t
x_sol_exact = x_exact(t)
# Se evalúa la primera derivada d1_x_exact en el conjunto de valores de t
d1_x_sol_exact = d1_x_exact(t)

# Se define el tamaño de la figura para la visualización
plt.figure(figsize=(8, 8))
# Se grafica la posición (x_sol_exact) en función del tiempo t
plt.plot(t, x_sol_exact, lw = 3, c = 'blue', label = 'position')
# Se grafica la velocidad (d1_x_sol_exact) en función del tiempo t
plt.plot(t, d1_x_sol_exact, lw = 3, c = 'red', label = 'speed')
# Se etiqueta el eje x como "time (s)"
plt.xlabel('time (s)')
# Se etiqueta el eje y como "distance (m)"
plt.ylabel('distance (m)')
# Se muestra la leyenda para identificar las curvas
plt.legend()
# Se muestra el gráfico
plt.show()

# Se define el tamaño de la figura para la visualización
plt.figure(figsize = (8, 8))
# Se grafica la velocidad en función de la posición (diagrama de fase)
plt.plot(x_sol_exact, d1_x_sol_exact, lw = 3)
# Se etiqueta el eje x como "distance (m)"
plt.xlabel('distance (m)')
# Se etiqueta el eje y como "speed (m/s)"
plt.ylabel('speed (m/s)')
plt.show()

import sympy as sp
import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

# Definición de la ecuación diferencial
x, m, b, t, k = sp.symbols('x m b t k')
x = sp.Function('x')(t)
d1_x = sp.diff(x, t)
d2_x = sp.diff(d1_x, t)

Eq = sp.Eq(m * d2_x, -b * d1_x - k * x)
d2_x_explicit = sp.solve(Eq, d2_x)[0]

# Conversión a funciones numéricas
dx_dt_f = sp.lambdify(d1_x, d1_x, modules='numpy')
dz_dt_f = sp.lambdify((t, k, m, b, x, d1_x), d2_x_explicit, modules='numpy')

def dSdt(t, S, k, m, b):
    x, z = S
    return [dx_dt_f(z), dz_dt_f(t, k, m, b, x, z)]

# Parámetros comunes
t0, tf, t_size = 0, 20 * np.pi, 2001
t = np.linspace(t0, tf, t_size)
x0, vx0 = 10, 0
S0 = [x0, vx0]

# Casos de amortiguamiento
casos = {
    "Sobreamortiguado": (2, 2, 8),  # b^2 > 4km
    "Críticamente amortiguado": (2, 2, 4),  # b^2 = 4km
    "Subamortiguado": (2, 2, 2)  # b^2 < 4km
}

plt.figure(figsize=(10, 6))
for tipo, (mn, kn, bn) in casos.items():
    sol = solve_ivp(dSdt, t_span=(t0, tf), y0=S0, method='RK45', t_eval=t, args=(kn, mn, bn))
    x_sol_numeric = sol.y[0]
    plt.plot(t, x_sol_numeric, label=tipo)
plt.xlabel('Tiempo (s)')
plt.ylabel('Posición (m)')
plt.title('Movimiento Amortiguado')
plt.legend()
plt.show()